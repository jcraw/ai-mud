Social System Requirements (Advanced NPC/Dialogue Interactions)

Overview

The Social system extends the existing AI-powered MUD engine with advanced NPC interaction mechanics including disposition tracking, dynamic knowledge management, and emote-based communication. It enables natural language interactions where players can converse, emote, or perform social actions with NPCs. NPCs respond dynamically via LLM, maintaining in-character behavior, personal knowledge bases, and variable dispositions. The system integrates with existing modules (:core, :reasoning, :perception, :memory) and includes stub interfaces for future :skill and :story modules. Emphasizes scalability via component-based design (ECS pattern), coherence through RAG, and database persistence for game state and canon lore.

Key Goals:

1. Immersive D&D-like conversations: Plain English inputs (talk, emote, threaten) yield realistic, varied responses
2. Disposition-driven interactions: NPCs' attitudes affect responses/help; changeable via player actions/events
3. Knowledge Management: NPCs draw from personal knowledge bases; generate and canonize new lore when asked unknown questions
4. Modularity: Component-based architecture allows any entity type to gain social capabilities
5. Scalability: Clean separation enables future systems to add components without bloating entity classes

Tech Stack: Kotlin, coroutines for async LLM/DB operations, immutable data classes, sealed classes for intents/events, SQLite database with migration path to PostgreSQL, existing modules (:core, :reasoning, :perception, :memory, :action)

---

Functional Requirements

1. COMPONENT-BASED ARCHITECTURE

1.1 Component System Design

Entity Component Host: All entities implement ComponentHost interface with:
  - components: Map<ComponentType, Component> - Polymorphic component storage
  - getComponent<T>(type): T? - Type-safe component retrieval
  - withComponent(component): Entity - Immutable component attachment
  - withoutComponent(type): Entity - Immutable component removal

Component Types (Enum):
  - SOCIAL - Social interaction data (disposition, personality, knowledge)
  - COMBAT - Combat stats and state (future expansion)
  - TRADING - Merchant/shop data (future expansion)
  - SKILL - Skill levels and progression (future :skill module)
  - STORY - Quest/narrative state (future :story module)
  - REPUTATION - Faction standings (future expansion)

Scalability: Components attach to ANY entity type (NPC, Player, Feature, Item). Each system adds components independently without modifying core Entity classes.

Example Usage:
  val npc = Entity.NPC(id = "guard", name = "Old Guard", components = emptyMap())
  val withSocial = npc.withComponent(SocialComponent(disposition = 0, personality = "gruff veteran"))
  val social = npc.getComponent<SocialComponent>(ComponentType.SOCIAL)

1.2 SocialComponent Definition

Data Class: SocialComponent(
  disposition: Int = 0,                  // -100 (hostile) to +100 (allied)
  personality: String,                   // e.g., "gruff warrior", "wise scholar"
  traits: List<String> = emptyList(),    // ["honorable", "greedy", "cowardly"]
  knowledgeEntries: List<String> = emptyList(), // IDs of knowledge in database
  conversationCount: Int = 0,            // Track interaction frequency
  lastInteractionTime: Long = 0L,        // Timestamp for time-based decay (future)
  componentType: ComponentType = ComponentType.SOCIAL
) : Component

Disposition Tiers:
  - ALLIED: disposition >= 75 (provides quest hints, secrets, help)
  - FRIENDLY: disposition >= 25 (helpful dialogue, trading benefits)
  - NEUTRAL: disposition >= -25 (standard interactions)
  - UNFRIENDLY: disposition >= -75 (curt responses, refuses help)
  - HOSTILE: disposition < -75 (attacks on sight, refuses dialogue)

Methods:
  - getDispositionTier(): DispositionTier - Calculate current tier
  - applyDispositionChange(delta: Int): SocialComponent - Apply event delta, clamped to -100..100
  - incrementConversationCount(): SocialComponent - Track interaction
  - addKnowledge(knowledgeId: String): SocialComponent - Add knowledge reference

---

2. DATABASE PERSISTENCE

2.1 Database Technology

Primary: SQLite (embedded, zero-config, single-file storage)
Future Migration: PostgreSQL (client-server for networked multi-player)
ORM: Kotlin JDBC with coroutines (lightweight, no heavy frameworks)

2.2 Schema Design

Tables:
1. entities - Core entity data (id, entity_type, name, description, timestamps)
2. components - Polymorphic component storage (entity_id, component_type, component_data as JSON)
3. social_components - Denormalized for SQL queries (entity_id, disposition, personality, conversation_count, timestamps)
4. social_traits - Many-to-many (entity_id, trait)
5. knowledge_entries - NPC knowledge base (id, entity_id, content, is_canon, source, timestamps)
6. knowledge_tags - Many-to-many categorization (knowledge_id, tag_key, tag_value)
7. vector_embeddings - RAG embeddings (id, knowledge_id, embedding as BLOB, model)
8. social_events_log - History tracking (id, entity_id, player_id, event_type, disposition_delta, timestamp)
9. world_state - Current world snapshot (id, current_room_id, game_time, state_data as JSON)
10. player_state - Player data (player_id, current_room_id, health, state_data as JSON)

Indexes:
  - social_components.disposition (for range queries)
  - knowledge_entries.entity_id (for NPC knowledge lookup)
  - knowledge_entries.is_canon (for canon lore queries)
  - social_events_log.entity_id, player_id, occurred_at (for history queries)

Constraints:
  - disposition CHECK (disposition >= -100 AND disposition <= 100)
  - Foreign keys with CASCADE DELETE for referential integrity

2.3 Repository Pattern

Interfaces (in :core/repository/):
  - ComponentRepository<T: Component> - Base CRUD operations
  - SocialComponentRepository - Social-specific queries (findByDispositionRange, findByTrait, updateDisposition)
  - KnowledgeRepository - Knowledge CRUD + RAG search (save, load, findByEntity, search, getCanonKnowledge)
  - SocialEventRepository - Event logging (log, getHistory, getPlayerHistory)

Implementations (in new :persistence module):
  - SQLiteSocialComponentRepository
  - SQLiteKnowledgeRepository
  - SQLiteSocialEventRepository

Benefits:
  - Abstracts database implementation (easy to swap SQLite â†’ PostgreSQL)
  - Testable with in-memory mock repositories
  - Clean separation of data access from business logic

---

3. DIALOGUE AND INTERACTION PIPELINE

3.1 Input Handling

Player Input: Natural language text (e.g., "What did you have for breakfast?", "I bow to you", "Tell me about the king")
Module: :perception (existing Intent system)

New Intent Types:
  - Intent.Emote(target: String, emoteAction: String) - Non-verbal actions
  - Intent.AskQuestion(target: String, question: String) - Knowledge queries
  - Existing: Intent.Talk, Intent.Persuade, Intent.Intimidate

3.2 Intent Parsing

LLM Classification: IntentRecognizer (existing) enhanced to recognize new intent types
Prompt Engineering: Updated system prompt to classify emotes and knowledge queries
Extraction: Parse target NPC and action details from player input

3.3 Emote System

Emote Types (Enum):
  - BOW (+5 disposition, keywords: "bow", "curtsy", "kneel")
  - WAVE (+2 disposition, keywords: "wave", "greet", "hello")
  - NOD (+1 disposition, keywords: "nod", "agree")
  - SHAKE_HEAD (-1 disposition, keywords: "shake head", "disagree")
  - LAUGH (+3 disposition, keywords: "laugh", "chuckle", "smile")
  - INSULT (-10 disposition, keywords: "insult", "mock", "taunt")
  - THREATEN (-15 disposition, keywords: "threaten", "menace", "glare")

Handler: EmoteHandler processes emote intents, generates narrative, applies disposition change

3.4 Knowledge Queries

Query Flow:
  1. Player asks question via Intent.AskQuestion
  2. NPCKnowledgeManager searches NPC's knowledge base (RAG semantic search)
  3. If known: Return existing knowledge
  4. If unknown: LLM generates new canon lore fitting world/NPC personality
  5. Store generated knowledge in database with is_canon = true
  6. Return answer to player

LLM Prompt: "Generate lore for NPC [name] with personality [personality]. Question: [question]. Stay consistent with world lore: [lore_summary]. Be concise (1-3 sentences)."

Persistence: All generated canon stored in knowledge_entries table with source = GENERATED

3.5 Skill Checks (Stub Interface)

Interface: SkillSystem (future :skill module)
  - checkSkill(playerId: String, skillName: String, difficulty: Int): SkillCheckResult
  - getSkillLevel(playerId: String, skillName: String): Int

Stub Implementation: StubSkillSystem (temporary)
  - Uses Random for d20 rolls + modifiers
  - Comment: "// TODO: INTEGRATION POINT - Replace with :skill module"

Usage: Persuasion/Intimidation checks call SkillSystem.checkSkill("CHARISMA", difficulty)

3.6 Disposition Updates

Event-Driven: Sealed class SocialEvent defines all disposition-changing events
Events:
  - HelpProvided (+20), HelpRefused (-10), Threatened (-15)
  - Intimidated (success: -20, failure: -5), Persuaded (success: +15, failure: -2)
  - GiftGiven (+5 to +30 based on value), EmotePerformed (varies by emote)
  - QuestCompleted (+30), QuestFailed (-25), AttackAttempted (-100)
  - ConversationHeld (+1)

Manager: DispositionManager.applyEvent(npc, playerId, event) - Applies delta, persists to DB, logs event

3.7 Response Generation

LLM Dialogue: NPCInteractionGenerator (existing, enhanced)
  - Disposition-aware tone: "Be [friendly/hostile/neutral] based on disposition [value]"
  - Knowledge-aware: Include relevant knowledge from NPC's knowledge base
  - History-aware: Use RAG to retrieve past conversations (via :memory MemoryManager)
  - Variability: Temperature 0.9 for creative, non-repetitive responses

Prompt Structure:
  System: "You are a dialogue generator. NPC personality: [personality]. Tone: [tone based on disposition]. Avoid repetition."
  User: "NPC: [name], Disposition: [value], Player said: [message]. Generate NPC's response."

Fallback: On LLM failure, return simple response: "[NPC] looks at you silently."

---

4. INTEGRATIONS

4.1 Story System (Stub Interface)

Interface: StorySystem (future :story module)
  - getRelevantQuests(npcId: String): List<QuestHint>
  - recordStoryEvent(event: StoryEvent)
  - getWorldLore(topic: String): String?

Stub Implementation: StubStorySystem
  - Returns empty list for quests (current quest system already exists)
  - Logs story events to console
  - Comment: "// TODO: INTEGRATION POINT - Replace with :story module"

Usage: High disposition NPCs call StorySystem.getRelevantQuests() to provide hints

4.2 Skill System (Stub Interface)

See 3.5 Skill Checks above.

4.3 Memory/RAG Integration

Existing System: :memory module with MemoryManager (vector database + RAG)
Usage:
  - Store conversations: MemoryManager.remember("Conversation with [npc]: [dialogue]", metadata)
  - Retrieve history: MemoryManager.recall("conversation with [npc]", k = 3)
  - Store knowledge: MemoryManager.remember(knowledgeEntry.content, metadata)
  - Search knowledge: MemoryManager.recall(question, k = 5) filtered by npcId metadata

Enhancement: Add metadata filtering to MemoryManager.recall() for NPC-specific knowledge

4.4 Quest Integration

Existing System: Quest system with QuestTracker (active, completed quests)
Enhancement: Add disposition bonus on quest completion
  - QuestTracker.claimReward() triggers SocialEvent.QuestCompleted
  - DispositionManager applies +30 disposition to quest giver NPC

---

5. MODULE STRUCTURE (NO NEW MODULE)

5.1 Distribution Across Existing Modules

:core (data models)
  - Component.kt, ComponentType enum, ComponentHost interface
  - SocialComponent.kt, DispositionTier enum
  - SocialEvent.kt sealed class hierarchy
  - KnowledgeEntry.kt, KnowledgeSource enum
  - EmoteType enum
  - repository/ package with interfaces

:perception (intent parsing)
  - Intent.kt - Add Intent.Emote, Intent.AskQuestion
  - IntentRecognizer.kt - Enhanced LLM prompt for new intents

:reasoning (business logic)
  - DispositionManager.kt - Event application, tone generation
  - EmoteHandler.kt - Emote processing and narrative
  - NPCKnowledgeManager.kt - Knowledge queries and canon generation
  - NPCInteractionGenerator.kt - Enhanced with disposition-aware dialogue
  - procedural/NPCGenerator.kt - Generate NPCs with SocialComponent
  - QuestTracker.kt - Enhanced with disposition bonus on completion
  - stubs/ package:
    - SkillSystem.kt interface + StubSkillSystem
    - StorySystem.kt interface + StubStorySystem

:memory (RAG/vector storage)
  - MemoryManager.kt - Enhanced with metadata filtering for knowledge queries

:persistence (NEW MODULE - database layer)
  - DatabaseConfig.kt - SQLite connection setup
  - migrations/ package - Schema migration scripts
  - repository/ package:
    - SQLiteSocialComponentRepository.kt
    - SQLiteKnowledgeRepository.kt
    - SQLiteSocialEventRepository.kt

:app, :client, :testbot (game loops)
  - Enhanced to handle Intent.Emote, Intent.AskQuestion
  - Apply disposition changes after social interactions
  - Persist components to database after updates

5.2 Data Flow

Input â†’ IntentRecognizer (LLM) â†’ Intent object
Intent â†’ Game Loop â†’ DispositionManager / EmoteHandler / NPCKnowledgeManager
Manager â†’ LLM (if needed) + Database (persistence) â†’ Updated NPC with components
Updated NPC â†’ Action module (formatting) â†’ Output to player

---

6. NON-FUNCTIONAL REQUIREMENTS

Performance:
  - Async/await coroutines for all LLM calls (non-blocking)
  - Database connection pooling for concurrent access
  - Cache frequently accessed components in memory (optional enhancement)
  - Batch database writes where possible

Scalability:
  - Component design allows 100+ NPCs without entity bloat
  - Database indexes enable fast queries (disposition range, trait lookup)
  - Efficient RAG search with vector embeddings (cosine similarity)

Security:
  - Sanitize player input before LLM prompts (prevent injection)
  - No direct SQL from user input (parameterized queries only)
  - LLM cannot execute database operations (read-only access via managers)

Testability:
  - Repository interfaces enable in-memory mock implementations
  - LLM client mockable for deterministic tests
  - All components immutable (easy to test state transitions)

Accessibility:
  - All text output compatible with screen readers
  - Future: Text-to-speech hooks for dialogue (voice acting)

---

7. TESTING REQUIREMENTS

7.1 Unit Tests

Module: Component in same module (e.g., :core/test, :reasoning/test)
Framework: JUnit 5, MockK for mocking
Coverage:
  - Component system (attach/detach, type safety, immutability)
  - SocialComponent (disposition tiers, delta application, knowledge addition)
  - SocialEvent (delta calculation, event types)
  - DispositionManager (event application, tone generation, price modifiers)
  - EmoteHandler (narrative generation, emote type matching)
  - NPCKnowledgeManager (RAG search, canon generation) - MOCK LLM
  - Intent parsing (emote/question recognition) - MOCK LLM

Mocking:
  - LLM client: Fixed responses for deterministic tests
  - Repositories: In-memory implementations
  - SkillSystem/StorySystem: Configurable stub outcomes

7.2 Integration Tests

Module: :app/src/test/kotlin/com/jcraw/app/integration/
Test Files:
  - AdvancedSocialInteractionTest.kt (emotes, questions, disposition changes)
  - KnowledgeSystemTest.kt (canon generation, persistence, RAG search)
  - DispositionEffectsTest.kt (dialogue tone, quest hints, behavioral changes)

Coverage:
  - End-to-end emote workflow (input â†’ intent â†’ handler â†’ disposition â†’ database â†’ output)
  - End-to-end knowledge query (input â†’ RAG search â†’ LLM generation â†’ database â†’ output)
  - Disposition changes persist across save/load
  - Multiple social interactions in sequence
  - Quest completion triggers disposition bonus

7.3 Bot Tests

Module: :testbot/src/test/kotlin/com/jcraw/mud/testbot/scenarios/
Test Files:
  - SocialPlaythroughTest.kt (win via social interaction, not combat)
  - KnowledgeQuestTest.kt (complete quest by asking NPCs questions)

Coverage:
  - Player gains ALLIED disposition through emotes and conversation
  - Player unlocks quest hints via high disposition
  - Player learns lore through knowledge queries
  - Player defeats boss via persuasion instead of combat

---

8. IMPLEMENTATION STRATEGY

Phase 1: Component System Foundation (3-4 hours)
  - Create Component interfaces and SocialComponent
  - Update Entity.NPC to implement ComponentHost
  - Create SocialEvent and KnowledgeEntry data classes
  - Unit tests for component system

Phase 2: Database Layer (4-5 hours)
  - Create schema.sql with all tables
  - Create :persistence module with repository implementations
  - Database migration system
  - Repository unit tests with in-memory SQLite

Phase 3: Core Business Logic (4-5 hours)
  - DispositionManager, EmoteHandler, NPCKnowledgeManager
  - Stub interfaces for SkillSystem and StorySystem
  - Unit tests with mocked repositories and LLM

Phase 4: Intent Recognition (2-3 hours)
  - Add Intent.Emote and Intent.AskQuestion
  - Enhance IntentRecognizer LLM prompt
  - Unit tests with mocked LLM

Phase 5: NPC Dialogue Enhancement (3-4 hours)
  - Update NPCInteractionGenerator with disposition awareness
  - Add knowledge query support
  - Integration tests for enhanced dialogue

Phase 6: Game Loop Integration (4-5 hours)
  - Update App.kt, EngineGameClient.kt, InMemoryGameEngine.kt
  - Handle new intents, apply disposition changes
  - Integration tests for full workflows

Phase 7: Procedural Generation Update (2-3 hours)
  - Update NPCGenerator to create NPCs with SocialComponent
  - Generate personality/traits based on dungeon theme
  - Unit tests for NPC generation

Phase 8: Quest/Memory Integration (2-3 hours)
  - Add quest completion disposition bonus
  - Enhance MemoryManager with metadata filtering
  - Integration tests

Phase 9: Documentation (2-3 hours)
  - Update CLAUDE.md, GETTING_STARTED.md, ARCHITECTURE.md
  - Create SOCIAL_SYSTEM.md guide
  - Update IMPLEMENTATION_LOG.md

Phase 10: Integration Testing & Polish (3-4 hours)
  - Comprehensive integration test suite
  - Bot playthrough tests
  - Bug fixes and performance tuning

Total Estimated Time: 30-40 hours

---

9. FUTURE ENHANCEMENTS

After V1 Implementation:
  - Trading system (TradingComponent with disposition-based prices)
  - Reputation system (ReputationComponent for faction standings)
  - Disposition decay over time (disposition slowly returns to neutral)
  - NPC-NPC relationships (NPCs have dispositions toward each other)
  - Conversation trees (branching dialogue options)
  - Persuasion mini-game (active persuasion beyond simple checks)
  - Voice acting hooks (text-to-speech for dialogue)
  - Advanced knowledge queries (multi-hop reasoning, contradictions)
  - PostgreSQL migration (networked multi-player with client-server DB)

---

SUCCESS CRITERIA

âœ… All entities support component attachment/removal
âœ… NPCs have SocialComponent with disposition tracking (-100 to +100)
âœ… Emote system functional (7 emote types affecting disposition)
âœ… Knowledge queries work (RAG search + LLM canon generation)
âœ… Disposition affects dialogue tone and quest hints
âœ… Database persistence works (SQLite with proper schema)
âœ… All social events logged and tracked
âœ… Stub interfaces defined for :skill and :story modules
âœ… ~70+ unit/integration tests passing (100% pass rate)
âœ… Full playthrough with social interactions works
âœ… Documentation updated

This defines the complete social system architecture. Implement iteratively following the phase plan.
