Scan the entire project codebase to identify all Kotlin (.kt) files exceeding 1000 lines (use shell tools like 'find . -name "*.kt" -exec wc -l {} \;' or equivalent to list and count lines). For each such file, refactor it to ensure the resulting files are under 1500 lines each (aim for 1000-2000 max, prioritizing logical modularity over strict counts). Break them into smaller, focused modules with clear separation of concerns (e.g., perception, reasoning, action, memory). Use Kotlin best practices: prefer sealed classes over enums, keep code simple and elegant (KISS), no overengineering. Update imports, references, tests, and docs as needed. Handle multi-file dependencies carefully to avoid breaks. Do not commit any changes to Gitâ€”save files directly and report diffs or changes in output for manual review.

Output a plan first: list all oversized files found, their line counts, proposed splits (new file names/structures), and rationale (e.g., group by feature). Then execute refactors step-by-step: for each file, create new files, move code, adjust callers, add tests (focus on behavior/contracts, mocks for LLMs/APIs, property-based where possible).

Be direct like Linus, never claim certainty (say "this should enhance maintainability" or "let's verify with tests"), use gpt-4o-mini for any LLM sub-calls, update docs inline, enforce UI unidirectional flow if applicable. If no large files found, just report that and exit.